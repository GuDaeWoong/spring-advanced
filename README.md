# SPRING ADVANCED


## Lv1 코드 개선

### 1. 문제 인식 및 정의
현재 회원가입 서비스 로직은 불필요한 연산을 수행하고 있습니다. 회원 정보 저장 전에 이메일 중복 검증이 제대로 이루어지지 않아, 이미 존재하는 이메일로 회원가입을 시도할 경우에 비밀번호 인코딩, 사용자 권한 삽입 작업이 실행되는 문제가 있습니다.

기존 코드 순서:

1. 비밀번호 인코딩
2. 유저 룰 삽입
3. 이메일 중복 검증 (이메일이 기존에 존재하는 값인지 확인)
4. 사용자 정보를 객체화
5. Repository를 통해 사용자 정보 저장
6. 사용자 정보를 토큰화

### 2. 해결 방안
개선점으로는 이메일 중복 검증을 최우선으로 수행하는 것입니다. 서비스 진입 시점에 이메일 중복 여부를 먼저 확인하여, 만약 중복된 이메일이라면 불필요한 다음 단계의 연산을 즉시 중단해야 합니다.

해결된 코드의 순서:

1. 이메일 중복 검증 (가장 먼저 수행)
  -  만약 이메일이 이미 존재한다면, 즉시 회원가입 실패 응답을 반환하고 로직 종료
2. 비밀번호 인코딩
3. 유저 룰 삽입
4. 사용자 정보를 객체화
5. Repository를 통해 사용자 정보 저장
6. 사용자 정보를 토큰화
  
이러한 순서 변경을 통해 이메일 중복 시 발생하는 불필요한 비밀번호 인코딩 및 사용자 권한 삽입 작업을 방지할 수 있습니다.

### 3. 해결 완료
이메일 중복 검증 로직의 위치를 회원가입 서비스 메서드의 가장 앞쪽으로 이동하여 코드의 효율성을 높였습니다.

<br>
<br>

## Lv2. N+1 문제

### 1. 문제 인식 및 정의
현재 JPQL 쿼리 @Query("SELECT t FROM Todo t LEFT JOIN FETCH t.user u ORDER BY t.modifiedAt DESC")는 모든 Todo 항목을 가져오며, 연결된 User 항목을 함께 가져오려 합니다. 하지만 User 엔티티의 FetchType이 LAZY로 설정되어 있어, Todo 항목을 조회할 때마다 해당 Todo에 연결된 User 정보를 가져오기 위해 추가적인 쿼리가 발생합니다.  
 예를 들어 todo 항목이 10개가 있어서 불러올때 10개의 User정보를 불러오기위해 한번씩 해서 10개의 추가 쿼리가 발생한다.위 쿼리를 발생시키기 위해 11번의 쿼리가 발생하는 문제가 있습니다.

### 2. 해결 방안

		1. FetchType.EAGER 사용
		   - 유저 엔티티의 fetch전략을 Eager로 변경하여 todo를 가져올때 항상 User도 함께 로드
		   장점 : 연관된 데이터를 항상 로드한다
		   단점 : 불필요한 데이터도 함께 로드하면서 메모리가 낭비된다
		2. JPQL의 JOIN FETCH 사용
		   - JPQL 쿼리에서 JOIN FETCH를 사용하여 연관된 엔티티를 한 번의 쿼리로 가져온다
		   장점 : 필요한 데이터만 가져올 수 있어서 유연성을 높일 수 있다
		   단점 : 쿼리를 직접 작성해야해서 코드가 복잡해질 수 있다
		3. @EntityGraph 사용
		   - @EntityGraph를 사용하여 특정 엔티티를 로드할 때 어떤 연관된 엔티티를 함께 로드할지를 명시적으로 지정
		   장점 : 코드가 간결해지고 가독성이 높아진다
		   단점 : 복잡한 쿼리에는 한계가 있다고 합니다
		4. DTO Projection 사용
		   - 필요한 데이터만을 담은 DTO를 사용하여 쿼리 결과를 반환
		   장점 : 필요한 데이터만을 가져와 성능을 최적화할 수 있다
		   단점 : 없다고 생각이 들지만 DTO클래스를 추가로 작성해야한다.


### 3. 해결 완료

@Query("SELECT t FROM Todo t LEFT JOIN FETCH t.user u ORDER BY t.modifiedAt DESC")   
기존 쿼리가 Todo와 User 정보만 필요로 하는 것을 고려하여, @EntityGraph를 사용해 Todo를 가져올 때 연관된 User 엔티티를 즉시 로딩하도록 설정했습니다. @EntityGraph(attributePaths = "user")
